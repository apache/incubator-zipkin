<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Zipkin, from Twitter</title>
    <link href="css/bootstrap-2.1.0.min.css" rel="stylesheet">
    <link href="css/docs.css" rel="stylesheet">
    <!--<link href="css/bootstrap-responsive-2.0.4.min.css" rel="stylesheet">-->
  </head>
  <body>
    <div class="navbar navbar-inverse navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="brand" href="index.html">Zipkin</a>
          <ul class="nav">
            <li><a href="architecture.html">Architecture</a></li>
            <li><a href="install.html">Install</a></li>
            <li><a href="hadoop.html">Hadoop</a></li>
            <li><a href="instrument.html">Instrumenting a library</a></li>
          </ul>
          <ul class="nav pull-right">
            <li><a href="https://github.com/twitter/zipkin">Github</a></li>
            <li><a href="https://twitter.com/zipkinproject">@ZipkinProject</a></li>
          </ul>
        </div>
      </div>
    </div>

      <header class="jumbotron masthead">
        <div class="inner">
          <h1>Zipkin, from Twitter</h1>
          <p class="lead">A distributed tracing system</p>
        </div>
      </header>

      <div class="container">
        <section id="examples">
<h2>Architecture</h2>

<p>These are the components that make up a fully fledged tracing system.</p>

<p><img src="images/architecture-0.png" alt="Zipkin Architecture (doc/architecture-0.png)"></p>

<h3>Instrumented libraries</h3>

<p>Tracing information is collected on each host using the instrumented libraries and sent to Zipkin.
When the host makes a request to another service, it passes a few tracing identifers along with the request so we can later tie the data together.</p>

<p><img src="images/architecture-1.png" alt="Zipkin Instrumentation architecture (doc/architecture-1.png)"></p>

<p>We have instrumented the libraries below to trace requests and to pass the required identifiers to the other services called in the request.</p>

<h5>Finagle</h5>

<blockquote>
<p>Finagle is an asynchronous network stack for the JVM that you can use to build asynchronous Remote Procedure Call (RPC) clients and servers in Java, Scala, or any JVM-hosted language.</p>
</blockquote>

<p><a href="https://github.com/twitter/finagle">Finagle</a> is used heavily inside of Twitter and it was a natural point to include tracing support. So far we have client/server support for Thrift and HTTP as well as client only support for Memcache and Redis.</p>

<p>To set up a Finagle server in Scala, just do the following.
Adding tracing is as simple as adding <a href="https://github.com/twitter/finagle/tree/master/finagle-zipkin">finagle-zipkin</a> as a dependency and a <code>tracer</code> to the ServerBuilder.</p>

<pre><code class="scala">ServerBuilder()
  .codec(ThriftServerFramedCodec())
  .bindTo(serverAddr)
  .name(&quot;servicename&quot;)
  .tracer(ZipkinTracer.mk())
  .build(new SomeService.FinagledService(queryService, new TBinaryProtocol.Factory()))
</code></pre>

<p>The tracing setup for clients is similar. When you&#39;ve specified the Zipkin tracer as above a small sample of your requests will be traced automatically. We&#39;ll record when the request started and ended, services and hosts involved.</p>

<p>In case you want to record additional information you can add a custom annotation in your code.</p>

<pre><code class="scala">Trace.record(&quot;starting that extremely expensive computation&quot;)
</code></pre>

<p>The line above will add an annotation with the string attached to the point in time when it happened. You can also add a key value annotation. It could look like this:</p>

<pre><code class="scala">Trace.recordBinary(&quot;http.response.code&quot;, &quot;500&quot;)
</code></pre>

<h5>Ruby Thrift</h5>

<p>There&#39;s a <a href="https://rubygems.org/gems/finagle-thrift">gem</a> we use to trace requests. In order to push the tracer and generate a trace id on a request you can use that gem in a RackHandler. See <a href="https://github.com/twitter/zipkin/blob/master/zipkin-web/config/application.rb">zipkin-web</a> for an example of where we trace the tracers.</p>

<p>For tracing client calls from Ruby we rely on the Twitter <a href="https://github.com/twitter/thrift_client">Ruby Thrift client</a>. See below for an example on how to wrap the client.</p>

<pre><code class="ruby">client = ThriftClient.new(SomeService::Client, &quot;127.0.0.1:1234&quot;)
client_id = FinagleThrift::ClientId.new(:name =&gt; &quot;service_example.sample_environment&quot;)
FinagleThrift.enable_tracing!(client, client_id), &quot;service_name&quot;)
</code></pre>

<h5>Querulous</h5>

<p><a href="https://github.com/twitter/querulous">Querulous</a> is a Scala library for interfacing with SQL databases. The tracing includes the timings of the request and the SQL query performed.</p>

<h5>Cassie</h5>

<p><a href="https://github.com/twitter/cassie">Cassie</a> is a Finagle based Cassandra client library. You set the tracer in Cassie pretty much like you would in Finagle, but in Cassie you set it on the KeyspaceBuilder.</p>

<pre><code class="scala">cluster.keyspace(keyspace).tracer(ZipkinTracer.mk())
</code></pre>

<h3>Transport</h3>

<p>We use Scribe to transport all the traces from the different services to Zipkin and Hadoop.
Scribe was developed by Facebook and it&#39;s made up of a daemon that can run on each server in your system.
It listens for log messages and routes them to the correct receiver depending on the category.</p>

<h3>Zipkin collector daemon</h3>

<p>Once the trace data arrives at the Zipkin collector daemon we check that it&#39;s valid, store it and the index it for lookups.</p>

<h3>Storage</h3>

<p>We settled on Cassandra for storage. It&#39;s scalable, has a flexible schema and is heavily used within Twitter. We did try to make this component pluggable though, so should not be hard to put in something else here.</p>

<h3>Zipkin query daemon</h3>

<p>Once the data is stored and indexed we need a way to extract it. This is where the query daemon comes in, providing the users with a simple Thrift api for finding and retrieving traces. See <a href="https://github.com/twitter/zipkin/blob/master/zipkin-thrift/src/main/thrift/zipkinQuery.thrift">the Thrift file</a>.</p>

<h3>UI</h3>

<p>Most of our users access the data via our UI. It&#39;s a Rails app that uses <a href="http://d3js.org/">D3</a> to visualize the trace data. Note that there is no built in authentication in the UI.</p>

<h2>Modules</h2>

<p><img src="https://github.com/twitter/zipkin/raw/master/doc/modules.png" alt="Modules (doc/modules.png)"></p>
        </section>
      </div>
      <footer class="footer">
        <div class="container">
          <p>Copyright 2012 Twitter, Inc.</p>
          <p>Licensed under the Apache License, Version 2.0: <a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a>
        </div>
      </footer>
  </body>
</html>
