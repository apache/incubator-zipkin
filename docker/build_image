#!/bin/sh
# This script is only a convenience as the build environment is controlled in
# the Dockerfile. That said, it uses only basic shell commands to help it work
# on developer laptops as well as CI nodes. Mainly, this centralizes the base
# Java image mappings and ensures all metadata needed is taken from pom.xml.
set -ue

TARGET=${1:-zipkin}

case ${TARGET} in
  zipkin )
    DOCKERFILE_PATH=docker/Dockerfile
    ;;
  zipkin-slim )
    DOCKERFILE_PATH=docker/Dockerfile
    ;;
  zipkin-ui )
    DOCKERFILE_PATH=docker/Dockerfile
    ;;
  zipkin-kafka )
    DOCKERFILE_PATH=docker/collector/kafka/Dockerfile
    ;;
  zipkin-cassandra )
    DOCKERFILE_PATH=docker/storage/cassandra/Dockerfile
    ;;
  zipkin-elasticsearch6 )
    DOCKERFILE_PATH=docker/storage/elasticsearch6/Dockerfile
    ;;
  zipkin-elasticsearch7 )
    DOCKERFILE_PATH=docker/storage/elasticsearch7/Dockerfile
    ;;
  zipkin-mysql )
    DOCKERFILE_PATH=docker/storage/mysql/Dockerfile
    ;;
  * )
    echo "Invalid TARGET: ${TARGET}"
    exit 1
esac

TAG=${2:-test}
RELEASE_VERSION=${RELEASE_VERSION:-master}

# Build the image
IMAGE=openzipkin/${TARGET}:${TAG}
echo Building image ${IMAGE}
docker build -f "${DOCKERFILE_PATH}" -t ${IMAGE} \
    --build-arg RELEASE_VERSION="${RELEASE_VERSION}" --target ${TARGET} .
